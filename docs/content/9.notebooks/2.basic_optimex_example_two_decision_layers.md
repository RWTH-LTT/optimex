---
title: Two Decision Layers Example
description: Jupyter notebook example - Two Decision Layers Example
---

# Two Decision Layers Example

::alert{type="info"}
This page is automatically generated from a Jupyter notebook. You can [download the original notebook](https://github.com/RWTH-LTT/optimex/blob/main/notebooks/basic_optimex_example_two_decision_layers.ipynb) to run it yourself.
::

```python
from datetime import datetime
import numpy as np
import bw2data as bd
from bw_temporalis import TemporalDistribution

bd.projects.set_current("standalone_optimex_example_products")
```

```plaintext
/Users/timodiepers/anaconda3/envs/optimex/lib/python3.11/site-packages/scikits/__init__.py:1: UserWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html. The pkg_resources package is slated for removal as early as 2025-11-30. Refrain from using this package or pin to Setuptools<81.
  __import__('pkg_resources').declare_namespace(__name__)

```


```python
if "foreground" in bd.databases:
    del bd.databases["foreground"] # to make sure we create the foreground from scratch
foreground = bd.Database("foreground")
foreground.register()
```


```python
# BIOSPHERE
biosphere_data = {
    ("biosphere3", "CO2"): {
        "type": bd.labels.biosphere_node_default,
        "name": "carbon dioxide",
        "CAS number": "000124-38-9"
    },
    ("biosphere3", "CH4"): {
        "type": bd.labels.biosphere_node_default,
        "name": "methane, fossil",
        "CAS number": "000074-82-8"
    },    
    ("biosphere3", "land_occupation"): {
        "type": bd.labels.biosphere_node_default,
        "name": "land occupation"
    }
}
bd.Database("biosphere3").write(biosphere_data)
```

```plaintext
100%|██████████| 3/3 [00:00<00:00, 8427.94it/s]
```

```plaintext
17:55:12+0100 [info     ] Vacuuming database            

```


```python
bd.Method(("GWP", "example")).write([
    (("biosphere3", "CO2"), 1),
    (("biosphere3", "CH4"), 27),
])

bd.Method(("land use", "example")).write([
    (("biosphere3", "land_occupation"), 1),
    (("biosphere3", "CH4"), 27),
])
```


```python
# BACKGROUND 2020
db_2020_data = {
    ("db_2020", "I1"): {
        "name": "node I1",
        "location": "somewhere",
        "type": bd.labels.chimaera_node_default,
        "reference product": "I1",
        "exchanges": [
            {"amount": 1, "type": bd.labels.production_edge_default, "input": ("db_2020", "I1")},
            {"amount": -3000, "type": bd.labels.biosphere_edge_default, "input": ("biosphere3", "CO2")},
        ],
    },
    ("db_2020", "I2"): {
        "name": "node I2",
        "location": "somewhere",
        "type": bd.labels.chimaera_node_default,
        "reference product": "I2",
        "exchanges": [
            {"amount": 1, "type": bd.labels.production_edge_default, "input": ("db_2020", "I2")},
            {"amount": 5, "type": bd.labels.biosphere_edge_default, "input": ("biosphere3", "CH4")},
        ],
    },
    ("db_2020", "I3"): {
        "name": "node I3",
        "location": "somewhere",
        "type": bd.labels.chimaera_node_default,
        "reference product": "I3",
        "exchanges": [
            {"amount": 1, "type": bd.labels.production_edge_default, "input": ("db_2020", "I3")},
            {"amount": 3, "type": bd.labels.biosphere_edge_default, "input": ("biosphere3", "CH4")},
            {"amount": 10, "type": bd.labels.biosphere_edge_default, "input": ("biosphere3", "land_occupation")},
        ],
    },
}
bg_2020 = bd.Database("db_2020")
bg_2020.write(db_2020_data)
bg_2020.metadata["representative_time"] = datetime(2020, 1, 1).isoformat() # optimex-specific: representative time of the background database
bg_2020.register()

# BACKGROUND 2035
db_2035_data = {
    ("db_2035", "I1"): {
        "name": "node I1",
        "location": "somewhere",
        "type": bd.labels.chimaera_node_default,
        "reference product": "I1",
        "exchanges": [
            {"amount": 1, "type": bd.labels.production_edge_default, "input": ("db_2035", "I1")},
            {"amount": -2500, "type": bd.labels.biosphere_edge_default, "input": ("biosphere3", "CO2")},
        ],
    },
    ("db_2035", "I2"): {
        "name": "node I2",
        "location": "somewhere",
        "type": bd.labels.chimaera_node_default,
        "reference product": "I2",
        "exchanges": [
            {"amount": 1, "type": bd.labels.production_edge_default, "input": ("db_2035", "I2")},
            {"amount": 2, "type": bd.labels.biosphere_edge_default, "input": ("biosphere3", "CH4")},
        ],
    },
    ("db_2035", "I3"): {
        "name": "node I3",
        "location": "somewhere",
        "type": bd.labels.chimaera_node_default,
        "reference product": "I3",
        "exchanges": [
            {"amount": 1, "type": bd.labels.production_edge_default, "input": ("db_2035", "I3")},
            {"amount": 2, "type": bd.labels.biosphere_edge_default, "input": ("biosphere3", "CH4")},
            {"amount": 7, "type": bd.labels.biosphere_edge_default, "input": ("biosphere3", "land_occupation")},        ],
    },
}
bg_2035 = bd.Database("db_2035")
bg_2035.write(db_2035_data)
bg_2035.metadata["representative_time"] = datetime(2035, 1, 1).isoformat() # optimex-specific: representative time of the background database
bg_2035.register()


# BACKGROUND 2050
db_2050_data = {
    ("db_2050", "I1"): {
        "name": "node I1",
        "location": "somewhere",
        "type": bd.labels.chimaera_node_default,
        "reference product": "I1",
        "exchanges": [
            {"amount": 1, "type": bd.labels.production_edge_default, "input": ("db_2050", "I1")},
            {"amount": -2200, "type": bd.labels.biosphere_edge_default, "input": ("biosphere3", "CO2")},
        ],
    },
    ("db_2050", "I2"): {
        "name": "node I2",
        "location": "somewhere",
        "type": bd.labels.chimaera_node_default,
        "reference product": "I2",
        "exchanges": [
            {"amount": 1, "type": bd.labels.production_edge_default, "input": ("db_2050", "I2")},
            {"amount": 1, "type": bd.labels.biosphere_edge_default, "input": ("biosphere3", "CH4")},
        ],
    },
    ("db_2050", "I3"): {
        "name": "node I3",
        "location": "somewhere",
        "type": bd.labels.chimaera_node_default,
        "reference product": "I3",
        "exchanges": [
            {"amount": 1, "type": bd.labels.production_edge_default, "input": ("db_2050", "I3")},
            {"amount": 1, "type": bd.labels.biosphere_edge_default, "input": ("biosphere3", "CH4")},
            {"amount": 7, "type": bd.labels.biosphere_edge_default, "input": ("biosphere3", "land_occupation")},        ],
    },
}
bg_2050 = bd.Database("db_2050")
bg_2050.write(db_2050_data)
bg_2050.metadata["representative_time"] = datetime(2050, 1, 1).isoformat() # optimex-specific: representative time of the background database
bg_2050.register()

```

```plaintext
19:00:27+0100 [warning  ] Not able to determine geocollections for all datasets. This database is not ready for regionalization.

```

```plaintext
100%|██████████| 3/3 [00:00<00:00, 20004.63it/s]
```

```plaintext
19:00:27+0100 [info     ] Vacuuming database            
19:00:27+0100 [warning  ] Not able to determine geocollections for all datasets. This database is not ready for regionalization.

```

```plaintext

100%|██████████| 3/3 [00:00<00:00, 58525.17it/s]
```

```plaintext
19:00:27+0100 [info     ] Vacuuming database            
19:00:27+0100 [warning  ] Not able to determine geocollections for all datasets. This database is not ready for regionalization.

```

```plaintext

100%|██████████| 3/3 [00:00<00:00, 23831.27it/s]
```

```plaintext
19:00:27+0100 [info     ] Vacuuming database            

```


```python
import bw2calc as bc
```


```python
from bw_temporalis import easy_timedelta_distribution
```


```python
# FOREGROUND - temporally distributed
foreground_data = {
    ("foreground", "Product 1"): {
        "name": "Product 1",
        "unit": "kg",
        "type": bd.labels.product_node_default,
    },
    ("foreground", "P1R1"): {
        "name": "Product 1 production, Route 1",
        "location": "somewhere",
        "type": bd.labels.process_node_default,
        "operation_time_limits": (0,6), # Optimex-specific: start and end year of operation phase
        "exchanges": [
            {
                "amount": 1,
                "type": bd.labels.production_edge_default,
                "input": ("foreground", "Product 1"),
                "temporal_distribution": easy_timedelta_distribution(
                    start=1,
                    end=6,
                    steps=6,
                    resolution="Y",
                    kind="uniform"
                ),
                "operation": True, # Optimex-specific: indicates that this exchange is part of the operation phase
            },
            {
                "amount": 27.5,
                "type": bd.labels.consumption_edge_default,
                "input": ("db_2020", "I1"),
                "temporal_distribution": TemporalDistribution( # Optimex-specific: temporal distribution of the exchange)
                    date=np.array([11], dtype="timedelta64[Y]"),
                    amount=np.array([1]),
                ),
            },
            {
                "amount": 35,
                "type": bd.labels.consumption_edge_default,
                "input": ("db_2020", "I3"),
                "temporal_distribution": TemporalDistribution( # Optimex-specific: temporal distribution of the exchange)
                    date=np.array([11], dtype="timedelta64[Y]"),
                    amount=np.array([1]),
                ),
            },
            {
                "amount": -20,
                "type": bd.labels.biosphere_edge_default,
                "input": ("biosphere3", "CO2"),
                "temporal_distribution": easy_timedelta_distribution(
                    start=1,
                    end=6,
                    steps=6,
                    resolution="Y",
                    kind="uniform"
                ),
                "operation": True,
            },
        ],
    },
    ("foreground", "P1R2"): {
        "name": "Product 1 production, Route 2",
        "location": "somewhere",
        "type": bd.labels.process_node_default,
        "operation_time_limits": (0,11),
        "exchanges": [
            {
                "amount": 1,
                "type": bd.labels.production_edge_default,
                "input": ("foreground", "Product 1"),
                "temporal_distribution": easy_timedelta_distribution(
                    start=1,
                    end=11,
                    steps=11,
                    resolution="Y",
                    kind="uniform"
                ),
                "operation": True,
            },
            {
                "amount": 10,
                "type": bd.labels.consumption_edge_default,
                "input": ("db_2020", "I2"),
                "temporal_distribution": TemporalDistribution( # Optimex-specific: temporal distribution of the exchange)
                    date=np.array([11], dtype="timedelta64[Y]"),
                    amount=np.array([1]),
                ),
            },
            {
                "amount": 5,
                "type": bd.labels.consumption_edge_default,
                "input": ("db_2020", "I3"),
                "temporal_distribution": TemporalDistribution( # Optimex-specific: temporal distribution of the exchange)
                    date=np.array([11], dtype="timedelta64[Y]"),
                    amount=np.array([1]),
                ),
            },
            {
                "amount": -20,
                "type": bd.labels.biosphere_edge_default,
                "input": ("biosphere3", "CO2"),
                "temporal_distribution": easy_timedelta_distribution(
                    start=1,
                    end=11,
                    steps=11,
                    resolution="Y",
                    kind="uniform"
                ),
                "operation": True,
            },
        ],
    },
    
    # ------------------------------------------------------------
    
    ("foreground", "Product 2"): {
        "name": "Product 2",
        "unit": "kg",
        "type": bd.labels.product_node_default,
    },
    ("foreground", "P2R1"): {
        "name": "Product 2 production, Route 1",
        "location": "somewhere",
        "type": bd.labels.process_node_default,
        "operation_time_limits": (0,15), # Optimex-specific: start and end year of operation phase
        "exchanges": [
            {
                "amount": 1,
                "type": bd.labels.production_edge_default,
                "input": ("foreground", "Product 2"),
                "temporal_distribution": easy_timedelta_distribution(
                    start=1,
                    end=15,
                    steps=15,
                    resolution="Y",
                    kind="uniform"
                ),
                "operation": True, # Optimex-specific: indicates that this exchange is part of the operation phase
            },
            {
                "amount": 1,
                "type": bd.labels.consumption_edge_default,
                "input": ("foreground", "Product 1"),
                "temporal_distribution": easy_timedelta_distribution(
                    start=1,
                    end=15,
                    steps=15,
                    resolution="Y",
                    kind="uniform"
                ),
                "operation": True,
            },
            {
                "amount": 18.5,
                "type": bd.labels.consumption_edge_default,
                "input": ("db_2020", "I3"),
                "temporal_distribution": TemporalDistribution( # Optimex-specific: temporal distribution of the exchange)
                    date=np.array([0], dtype="timedelta64[Y]"),
                    amount=np.array([1]),
                ),
            },
            {
                "amount": 3,
                "type": bd.labels.biosphere_edge_default,
                "input": ("biosphere3", "CO2"),
                "temporal_distribution": easy_timedelta_distribution(
                    start=1,
                    end=15,
                    steps=15,
                    resolution="Y",
                    kind="uniform"
                ),
                "operation": True,
            },
        ],
    },
    ("foreground", "P2R2"): {
        "name": "Product 2 production, Route 2",
        "location": "somewhere",
        "type": bd.labels.process_node_default,
        "operation_time_limits": (0,7),
        "exchanges": [
            {
                "amount": 1,
                "type": bd.labels.production_edge_default,
                "input": ("foreground", "Product 2"),
                "temporal_distribution": easy_timedelta_distribution(
                    start=1,
                    end=7,
                    steps=7,
                    resolution="Y",
                    kind="uniform"
                ),
                "operation": True,
            },
            {
                "amount": 1,
                "type": bd.labels.consumption_edge_default,
                "input": ("foreground", "Product 1"),
                "temporal_distribution": easy_timedelta_distribution(
                    start=1,
                    end=7,
                    steps=7,
                    resolution="Y",
                    kind="uniform"
                ),
                "operation": True,
            },
            {
                "amount": 15.5,
                "type": bd.labels.consumption_edge_default,
                "input": ("db_2020", "I2"),
                "temporal_distribution": TemporalDistribution( # Optimex-specific: temporal distribution of the exchange)
                    date=np.array([0], dtype="timedelta64[Y]"),
                    amount=np.array([1]),
                ),
            },
            {
                "amount": -10,
                "type": bd.labels.biosphere_edge_default,
                "input": ("biosphere3", "CO2"),
                "temporal_distribution": easy_timedelta_distribution(
                    start=1,
                    end=7,
                    steps=7,
                    resolution="Y",
                    kind="uniform"
                ),
                "operation": True,
            },
        ],
    },
}
fg = bd.Database("foreground")
fg.write(foreground_data)
fg.register()
```

```plaintext
19:00:30+0100 [warning  ] Not able to determine geocollections for all datasets. This database is not ready for regionalization.

```

```plaintext
100%|██████████| 6/6 [00:00<00:00, 18117.94it/s]
```

```plaintext
19:00:30+0100 [info     ] Vacuuming database            

```


### Defining Demand of Functional Unit in `optimex`


```python
# Define temporally distributed demand from 2020 to 2030
years = range(2025, 2050)
rng = np.random.default_rng(42)
td_demand = TemporalDistribution(
    date=np.array([datetime(year, 1, 1).isoformat() for year in years], dtype="datetime64[s]"),
    amount=rng.random(len(years)) * 10,
)
functional_demand = {bd.get_node(database="foreground", name="Product 2"): td_demand}
```


## optimex


```python
from optimex import lca_processor

lca_config = lca_processor.LCAConfig(
    demand = functional_demand,
    temporal= {
        "start_date": datetime(2020, 1, 1),
        "temporal_resolution": "year",
        "time_horizon": 100,
    },
    characterization_methods=[
        {
            "category_name": "climate_change",
            "brightway_method": ("GWP", "example"),
            # "metric": "CRF",
        },
        # {
        #     "category_name": "land_use",
        #     "brightway_method": ("land use", "example"),
        # },
    ],
)
```


With all the necessary components defined, we are now ready to gather the LCI and prepare for optimization.

To summarize, we have:

- Defined a **custom biosphere** with elementary flows (e.g., CO₂, CH₄).
- Created **foreground** and **background** systems, including temporal distributions.
- Registered **characterization methods** (static or dynamic).
- Specified **demand over time** using `TemporalDistribution`.
- Marked processes as **functional flows** to indicate eligible supply routes.
- (Optionally) Enabled **dynamic characterization** for more time-sensitive impact assessment.


```python
lca_data_processor = lca_processor.LCADataProcessor(lca_config)
```

```plaintext
2025-12-18 19:00:31.461 | INFO     | optimex.lca_processor:_parse_demand:385 - Identified demand in system time range of %s for products %s
2025-12-18 19:00:31.470 | INFO     | optimex.lca_processor:_construct_foreground_tensors:521 - Constructed foreground tensors.
2025-12-18 19:00:31.471 | INFO     | optimex.lca_processor:log_tensor_dimensions:516 - Technosphere (external) shape: (4 processes, 3 flows, 2 years) with 6 total entries.
2025-12-18 19:00:31.472 | INFO     | optimex.lca_processor:log_tensor_dimensions:516 - Internal demand shape: (2 processes, 1 flows, 15 years) with 22 total entries.
2025-12-18 19:00:31.472 | INFO     | optimex.lca_processor:log_tensor_dimensions:516 - Biosphere shape: (4 processes, 1 flows, 15 years) with 39 total entries.
2025-12-18 19:00:31.473 | INFO     | optimex.lca_processor:log_tensor_dimensions:516 - Production shape: (4 processes, 2 flows, 15 years) with 39 total entries.
2025-12-18 19:00:31.473 | INFO     | optimex.lca_processor:_calculate_inventory_of_db:560 - Calculating inventory for database: db_2020
2025-12-18 19:00:31.491 | INFO     | optimex.lca_processor:_calculate_inventory_of_db:576 - Factorized LCI for database: db_2020
100%|██████████| 3/3 [00:00<00:00, 126.53it/s]
2025-12-18 19:00:31.517 | INFO     | optimex.lca_processor:_calculate_inventory_of_db:616 - Finished calculating inventory for database: db_2020
2025-12-18 19:00:31.518 | INFO     | optimex.lca_processor:_calculate_inventory_of_db:560 - Calculating inventory for database: db_2035
2025-12-18 19:00:31.525 | INFO     | optimex.lca_processor:_calculate_inventory_of_db:576 - Factorized LCI for database: db_2035
100%|██████████| 3/3 [00:00<00:00, 190.22it/s]
2025-12-18 19:00:31.544 | INFO     | optimex.lca_processor:_calculate_inventory_of_db:616 - Finished calculating inventory for database: db_2035
2025-12-18 19:00:31.546 | INFO     | optimex.lca_processor:_calculate_inventory_of_db:560 - Calculating inventory for database: db_2050
2025-12-18 19:00:31.552 | INFO     | optimex.lca_processor:_calculate_inventory_of_db:576 - Factorized LCI for database: db_2050
100%|██████████| 3/3 [00:00<00:00, 192.70it/s]
2025-12-18 19:00:31.570 | INFO     | optimex.lca_processor:_calculate_inventory_of_db:616 - Finished calculating inventory for database: db_2050
2025-12-18 19:00:31.571 | INFO     | optimex.lca_processor:_prepare_background_inventory:723 - Computed background inventory using method: sequential
2025-12-18 19:00:31.574 | INFO     | optimex.lca_processor:_construct_characterization_tensor:834 - Static characterization for method climate_change completed.
2025-12-18 19:00:31.574 | INFO     | optimex.lca_processor:_construct_mapping_matrix:777 - Constructed mapping matrix for background databases based on linear interpolation.

```


```python
from optimex import converter
manager = converter.ModelInputManager()
optimization_model_inputs = manager.parse_from_lca_processor(lca_data_processor) 
```


### Saving and Reusing Model Inputs

Gathering all LCA-relevant data—including biosphere flows, foreground and background systems, temporal distributions, and characterization methods—can be **computationally expensive**.  
If you're working with similar scenarios or want to explore different optimization settings, it's often unnecessary to rebuild the entire setup from scratch.

 `OptimizationModelInputs`: Interface for Efficient Reuse

To address this, `optimex` provides a dedicated interface called **`OptimizationModelInputs`**. This object:

- Collects all the structured LCA data needed for optimization.
- Can be **saved** to disk for future use.
- Can be **loaded** later to resume or modify the scenario.
- Allows you to tweak configurations (e.g., demand, technologies, time horizon) without re-running the full data setup.

In the next steps, we’ll create and populate a `OptimizationModelInputs` object, and use it to prepare for running the optimization in `optimex`.


```python
from optimex import converter
manager = converter.ModelInputManager()
```


```python
optimization_model_inputs = manager.parse_from_lca_processor(lca_data_processor) 
# manager.save("model_inputs.json") # if you want to save the model inputs to a file
# manager.load("model_inputs.json") # if you want to load the model inputs from a file
optimization_model_inputs.model_dump()
```

```plaintext
{'PROCESS': ['P2R1', 'P1R2', 'P1R1', 'P2R2'],
 'PRODUCT': ['Product 2', 'Product 1'],
 'INTERMEDIATE_FLOW': ['I3', 'I2', 'I1'],
 'ELEMENTARY_FLOW': ['CO2', 'CH4', 'land_occupation'],
 'BACKGROUND_ID': ['db_2020', 'db_2035', 'db_2050'],
 'PROCESS_TIME': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],
 'SYSTEM_TIME': [2020,
  2021,
  2022,
  2023,
  2024,
  2025,
  2026,
  2027,
  2028,
  2029,
  2030,
  2031,
  2032,
  2033,
  2034,
  2035,
  2036,
  2037,
  2038,
...
(output truncated)
...
  ('climate_change', 'CH4', 2043): 27.0,
  ('climate_change', 'CH4', 2044): 27.0,
  ('climate_change', 'CH4', 2045): 27.0,
  ('climate_change', 'CH4', 2046): 27.0,
  ('climate_change', 'CH4', 2047): 27.0,
  ('climate_change', 'CH4', 2048): 27.0,
  ('climate_change', 'CH4', 2049): 27.0},
 'operation_time_limits': {'P2R1': (0, 15),
  'P1R2': (0, 11),
  'P1R1': (0, 6),
  'P2R2': (0, 7)},
 'category_impact_limit': None,
 'process_limits_max': None,
 'process_limits_min': None,
 'cumulative_process_limits_max': None,
 'cumulative_process_limits_min': None,
 'process_coupling': None,
 'process_names': {'P2R1': 'Product 2 production, Route 1',
  'P1R2': 'Product 1 production, Route 2',
  'P1R1': 'Product 1 production, Route 1',
  'P2R2': 'Product 2 production, Route 2'},
 'process_limits_max_default': inf,
 'process_limits_min_default': 0.0,
 'cumulative_process_limits_max_default': inf,
 'cumulative_process_limits_min_default': 0.0}
```


### Creating the Optimization Model

With the `OptimizationModelInputs` object prepared, we can now **populate the optimization model** in `optimex`.

This step involves specifying:

- A **name** for the model,
- The **impact category** to be minimized (e.g., `"climate_change"`),
- Whether to enable **flexible operation** (i.e., allow processes to run at varying capacity over time).



```python
from optimex import optimizer

model = optimizer.create_model(
    optimization_model_inputs,
    name = "demo_simple_example",
    objective_category = "climate_change",
)
```

```plaintext
2025-12-18 19:00:34.108 | INFO     | optimex.optimizer:create_model:123 - Creating sets
2025-12-18 19:00:34.110 | INFO     | optimex.optimizer:create_model:165 - Creating parameters
2025-12-18 19:00:34.113 | INFO     | optimex.optimizer:create_model:337 - Creating variables

```


## Solving the Optimization Model

Once the model is created, you can solve it using available solvers such as **GLPK** or **Gurobi**.

Use the `solve_model` function from `optimex` to run the optimization. It offers several parameters to control solver options, convergence criteria, and output verbosity.

For detailed information on all parameters and solver configurations, please refer to the documentation.


```python
m, obj, results = optimizer.solve_model(model, solver_name="glpk", tee=False) # choose solver here, e.g. "gurobi", "cplex", "glpk", etc.
```

```plaintext
2025-12-18 19:00:34.667 | INFO     | optimex.optimizer:solve_model:694 - Solver [glpk] termination: other

```

```plaintext
ERROR: evaluating object as numeric value: var_installation[P2R1,2020]
        (object: <class 'pyomo.core.base.var.VarData'>)
    No value for uninitialized NumericValue object var_installation[P2R1,2020]
ERROR: evaluating object as numeric value: OBJ
        (object: <class 'pyomo.core.base.objective.ScalarObjective'>)
    No value for uninitialized NumericValue object var_installation[P2R1,2020]

```

::alert{type="error"}
```
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
Cell In[95], line 1
----> 1 m, obj, results = optimizer.solve_model(model, solver_name="glpk", tee=False) # choose solver here, e.g. "gurobi", "cplex", "glpk", etc.

File ~/Documents/Coding/optimex/optimex/optimizer.py:710, in solve_model(model, solver_name, solver_args, solver_options, tee, compute_iis, **solve_kwargs)
    707         logger.warning(f"IIS generation failed: {e}")
    709 # 4) Denormalize objective
--> 710 scaled_obj = pyo.value(model.OBJ)
    711 fg_scale = getattr(model, "scales", {}).get("foreground", 1.0)
    712 catscales = getattr(model, "scales", {}).get("characterization", {})

File ~/anaconda3/envs/optimex/lib/python3.11/site-packages/pyomo/common/numeric_types.py:382, in value(obj, exception)
    377 if exception:
    378     #
    379     # Here, we try to catch the exception
    380     #
    381     try:
--> 382         tmp = obj(exception=True)
    383         if tmp is None:
    384             raise ValueError(
    385                 "No value for uninitialized NumericValue object %s" % (obj.name,)
    386             )

File ~/anaconda3/envs/optimex/lib/python3.11/site-packages/pyomo/core/base/objective.py:432, in ScalarObjective.__call__(self, exception)
...
(output truncated)
...
    931 _idx += 1
--> 932 flag, value = self.visiting_potential_leaf(_sub)
    933 if flag:
    934     _result.append(value)

File ~/anaconda3/envs/optimex/lib/python3.11/site-packages/pyomo/core/expr/visitor.py:1215, in _EvaluationVisitor.visiting_potential_leaf(self, node)
   1212     return False, None
   1214 if node.is_numeric_type():
-> 1215     return True, value(node, exception=self.exception)
   1216 elif node.is_logical_type():
   1217     return True, value(node, exception=self.exception)

File ~/anaconda3/envs/optimex/lib/python3.11/site-packages/pyomo/common/numeric_types.py:384, in value(obj, exception)
    382     tmp = obj(exception=True)
    383     if tmp is None:
--> 384         raise ValueError(
    385             "No value for uninitialized NumericValue object %s" % (obj.name,)
    386         )
    387     return tmp
    388 except TemplateExpressionError:
    389     # Template expressions work by catching this error type. So
    390     # we should defer this error handling and not log an error
    391     # message.

ValueError: No value for uninitialized NumericValue object var_installation[P2R1,2020]
```
::


## Postprocessing the Optimization Results

`optimex` offers powerful tools to analyze and visualize the optimal solution in detail. Key aspects you can explore include:

- **Impact over time:** View time-resolved environmental impacts according to the chosen impact category.
- **Demand fulfillment:** Track how the demand for the functional product evolves and by which processes it is met during the modeled period.
- **Installation timeline:** Identify when each process was installed during the transition pathway.
- **Operation profiles:** Examine the operational levels of processes year-by-year, especially important for flexible operation scenarios.
- **Production of functional flows:** Analyze how much of the functional product each process produces over time.

Together, these outputs provide a comprehensive understanding of the system’s dynamics, helping you evaluate trade-offs and the timing of interventions. Below is a demosntartion of some postprocessing tools.



```python
import pyomo.environ as pyo

operation_values = {
    (p, t): pyo.value(m.var_installation[p, t])
    for p in m.PROCESS
    for t in m.SYSTEM_TIME
}
operation_values
```

```plaintext
{('P2R2', 2020): 0.0,
 ('P2R2', 2021): 0.0,
 ('P2R2', 2022): 0.0,
 ('P2R2', 2023): 0.0,
 ('P2R2', 2024): 0.0,
 ('P2R2', 2025): 0.0,
 ('P2R2', 2026): 0.0,
 ('P2R2', 2027): 0.0,
 ('P2R2', 2028): 0.0,
 ('P2R2', 2029): 0.0,
 ('P2R2', 2030): 0.0,
 ('P2R2', 2031): 0.0,
 ('P2R2', 2032): 0.0,
 ('P2R2', 2033): 0.0,
 ('P2R2', 2034): 0.0,
 ('P2R2', 2035): 0.0,
 ('P2R2', 2036): 4.44089209850063e-16,
 ('P2R2', 2037): 0.0,
 ('P2R2', 2038): 0.0,
 ('P2R2', 2039): 0.0,
 ('P2R2', 2040): 0.0,
 ('P2R2', 2041): 1.92314527321141,
 ('P2R2', 2042): 0.0,
 ('P2R2', 2043): 3.57688256332166,
 ('P2R2', 2044): 0.0,
...
(output truncated)
...
 ('P2R1', 2025): 7.73956048555963,
 ('P2R1', 2026): 0.0,
 ('P2R1', 2027): 0.846418713554191,
 ('P2R1', 2028): 0.0,
 ('P2R1', 2029): 0.0,
 ('P2R1', 2030): 1.17024431725373,
 ('P2R1', 2031): 0.0,
 ('P2R1', 2032): 0.0,
 ('P2R1', 2033): 0.0,
 ('P2R1', 2034): 0.0,
 ('P2R1', 2035): 0.0,
 ('P2R1', 2036): 0.0,
 ('P2R1', 2037): 0.0,
 ('P2R1', 2038): 0.0,
 ('P2R1', 2039): 0.0,
 ('P2R1', 2040): 0.0,
 ('P2R1', 2041): 1.60603956613901,
 ('P2R1', 2042): 0.0,
 ('P2R1', 2043): 0.0,
 ('P2R1', 2044): 0.0,
 ('P2R1', 2045): 0.0,
 ('P2R1', 2046): 0.0,
 ('P2R1', 2047): 0.0,
 ('P2R1', 2048): 0.0,
 ('P2R1', 2049): 0.0}
```


```python
from optimex import postprocessing
pp = postprocessing.PostProcessor(m)
```


```python
pp.plot_installation()
```

```plaintext
<Figure size 1000x600 with 1 Axes>
```

::alert{type="info"}
*Note: Image output from this cell is not displayed in the documentation.*
::


```python
pp.plot_operation()
```

```plaintext
<Figure size 1000x600 with 1 Axes>
```

::alert{type="info"}
*Note: Image output from this cell is not displayed in the documentation.*
::


```python
pp.plot_production_vs_capacity(show_grouped_bars=True)
```

```plaintext
<Figure size 1000x600 with 1 Axes>
```

::alert{type="info"}
*Note: Image output from this cell is not displayed in the documentation.*
::


```python
pp.plot_impacts()
```

```plaintext
<Figure size 2000x600 with 1 Axes>
```

::alert{type="info"}
*Note: Image output from this cell is not displayed in the documentation.*
::


```python
pp.get_demand()
```

```plaintext
Product  Product 1  Product 2
Time                         
2020           0.0   0.000000
2021           0.0   0.000000
2022           0.0   0.000000
2023           0.0   0.000000
2024           0.0   0.000000
2025           0.0   7.739560
2026           0.0   4.388784
2027           0.0   8.585979
2028           0.0   6.973680
2029           0.0   0.941773
2030           0.0   9.756224
2031           0.0   7.611397
2032           0.0   7.860643
2033           0.0   1.281136
2034           0.0   4.503859
2035           0.0   3.707980
2036           0.0   9.267650
2037           0.0   6.438651
2038           0.0   8.227616
2039           0.0   4.434142
2040           0.0   2.272387
2041           0.0   5.545848
2042           0.0   0.638173
2043           0.0   8.276312
2044           0.0   6.316644
2045           0.0   7.580877
2046           0.0   3.545260
2047           0.0   9.706980
2048           0.0   8.931211
2049           0.0   7.783835
```


```python
pp.get_installation()
```

```plaintext
Process      P1R1      P1R2      P2R1      P2R2
Time                                           
2020     0.000000  6.699527  0.000000  0.000000
2021     0.000000  0.000000  0.000000  0.000000
2022     0.000000  0.000000  0.000000  0.000000
2023     0.000000  0.000000  0.000000  0.000000
2024     0.000000  0.000000  0.000000  0.000000
2025     0.000000  1.040034  7.739560  0.000000
2026     0.000000  0.000000  0.000000  0.000000
2027     0.000000  0.846419  0.846419  0.000000
2028     0.000000  7.381197  0.000000  0.000000
2029     0.000000  0.000000  0.000000  0.000000
2030     0.000000  0.000000  0.000000  1.281136
2031     0.000000  0.000000  0.000000  0.000000
2032     0.000000  0.000000  0.000000  0.000000
2033     0.000000  0.000000  0.000000  0.000000
2034     0.000000  0.000000  0.000000  2.426844
2035     0.000000  0.000000  0.000000  0.000000
2036     0.000000  0.000000  0.000000  0.000000
2037     0.000000  0.000000  0.000000  0.000000
2038     0.000000  0.000000  0.000000  0.000000
2039     2.272387  1.147376  0.349440  0.000000
2040     0.000000  0.000000  0.000000  0.426329
2041     2.126084  0.000000  0.000000  1.496816
2042     0.000000  0.000000  0.000000  7.434395
2043     7.783835  0.000000  0.000000  0.000000
2044     0.000000  0.000000  0.000000  0.000000
2045     0.000000  0.000000  0.000000  0.000000
2046     0.000000  0.000000  0.000000  0.000000
2047     0.000000  0.000000  0.000000  0.000000
2048     0.000000  0.000000  0.000000  0.000000
2049     0.000000  0.000000  0.000000  0.000000
```


```python
pp.plot_production_and_demand()
```

```plaintext
<Figure size 1000x600 with 1 Axes>
```

::alert{type="info"}
*Note: Image output from this cell is not displayed in the documentation.*
::

